# var, hoisting, scope
이 문서를 시작하기 전에 일단 ```호이스팅(hoisting)```과 ```scope```의 개념에 대해서 알고 가보자.
### 호이스팅
javascript 언어의 특징 중 하나로 프로그램을 처음 실행하는 과정에서 **함수 내부 선언**을 제외한 모든 선언에 대해서 전역에게 선언 여부와 주소를 통보하는 것을 말한다.
### scope
scope는 ```Door scope```와 동일하다고 보면 된다. 현관문에 달려있는 ```Door scope```는 내부에서 바깥의 상황을 볼 수는 있어도 외부에서 내부의 상황을 볼 수는 없다. 이 원리를 그대로 변수나 함수 선언에 적용한 것이라고 보면 된다. 변수나 함수는 특정 ```scope```내에서 정의가 되는데, 이 ```scope```보다 상위의 ```scope```에서는 이 곳에서 선언 된 모든 것을 볼 수가 없다. 하지만, 해당 ```scope```를 포함한 하위의 ```scope```는 **선언된 모든 것들에 대한 참조가 가능하다.**

일종의 **지역**이라고 보면 된다.
## 문제점
호이스팅의 문제점은 프로그램에서 선언이 되지 않은 변수를 사용해도 에러를 뱉지 않는다는 것에 있다.

예를 들어보자, ```C``` ```C++``` ```JAVA```와 같은 언어로 처음 시작한 사람은 알겠지만, 선언되지 않은 변수나 함수를 사용하면 컴파일러가 무조건적으로 에러를 뱉는다.
하지만 자바스크립트는 아래와 같은 코드를 전혀 문제 없이 받아들인다.
```javascript
console.log(a);
var a = 1;
console.log(a);
```
위 코드는 변수 ```a```가 선언되기 전에 ```console.log```를 통해 출력을 시도하는 코드이다.
일반적인 프로그래밍 언어라면 ```a```의 **참조에러**를 띄우며 죽어야 한다. 하지만 javascript의 출력 결과는 아래와 같다.
```
undefined
1
```
왜 이럴까? 이는 자바스크립트가 갖고있는 **호이스팅**이라는 특징과, 포용력이 높은 ```var``` 키워드가 만들어내는 **환장의 콜라보**이다.
Javascript는 위에서도 설명한 **호이스팅**의 특징을 갖고있다. 프로그램이 시작되면 프로그램 내부에 선언 된 모든 변수, 상수, 함수에 대한 정보를 갖고 시작한다는 얘기이다.
그러다보니 초기화가 되지는 않았지만 **"이러한 이름의 변수가 아랫줄 어딘가에서 선언이 될거야!** 라는 예언을 들었기 때문에 에러를 띄우는게 아닌, ```undefined``` 값을 보여주고 끝내는 것이다.

심지어 반복문에서도 이러한 점이 문제가 된다.
```javascript
for (var i = 0; i < 5; i += 1) {
  console.log(i);
}
console.log(i);
```
모두 알겠지만 반복문과 조건문은 각자 고유의 스코프를 가지고 있다. 다시 말해, 반복문이나 조건문 안에서 정의 된 내용에 대해서는 바깥에서 참조를 할 수가 없어야 한다는 얘기이다.
하지만 호이스팅은 함수 내부 선언 외 모든 선언에 대해 전역에서 선언 여부를 관리한다. 그러다보니 위 소스코드의 결과는 아래와 같이 출력된다.
```
1
2
3
4
5
```
원래라면 ```4```까지 출력되고 말았어야 할 코드에서 ```5```마저 출력이 된다. 전역에서 **```i```변수의 선언 여부 및 주소를 관리하고 있기 때문이다.**
이 흐름을 전부 파악하고 그것에 맞게 코드를 구성한다면 사실 문제는 되지 않겠지만, 프로그램 흐름 상 자연스럽지 않은 흐름은 수많은 버그와 보안상 이슈를 낳는다. 그래서 javascript ES6에서는 ```let```의 등장과 함께 ```var``` 키워드의 사용을 금지하는 추세이다.
## let
위 호이스팅의 문제를 제거하기 위해서 나온 변수 선언 방식이 ```let```이다.

```let```은 기존의 ```var```를 완전히 대체한다. 하지만 호이스팅으로 인한 이슈를 제거한 버전이라고 보면 된다.
```javascript
console.log(a);
let a = 1;
console.log(a);
```
아까 전에 예시로 들었던 이 코드를 보자. ```var```에서 ```let```으로 변경했을 뿐인데, 출력되는 결과는 완전 달라진다.
```
Uncaught ReferenceError: a is not defined
    at <anonymous>:1:13
(anonymous) @ VM57:1
```
이렇게 에러를 띄우게 된다. 이렇게 되면 **어딘가에서 정의는 됐지만 어딘지는 모르는 이상한 변수**를 포용하지 않고 깔끔하게 에러를 보여줌으로써 ```try ... catch```문으로 핸들링도 할 수 있게 된다.